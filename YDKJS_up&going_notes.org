#Ch1
quick overview of what you'll want to learn+practice to get into programming

Code
  Language=syntax. code=set of instructions in a given language.
  Saved in txt file.

  Statement: group of words/numbers/operators performing specific task.
             Conclude with ;
             Made up of 1 or more Expressions
  a=b*2; where a/b = variables, 2 = literal value (stands alone), =/* = operators.

  Variables: holds values

  Operators: Performs actions with values and variables

  Expressions: a reference to variable or value, or set thereof, combined    with         operators.
              For a = b * 2
              2 = literal value expression
              b = variable expression (retrieve current value)
              b * 2 = arithmetic expression (execute multiplication), also 'expression statement' (stands alone, not useful bc does nothing with output)
              a = b * 2 = assignment expression (assign result of b*2 exp to variable a)
              alert( a ); = call expression statement

Compiler/Interpreter: runs/executes/compiles code into commands
  Interpreting code: top to bottom, line by line, each time program runs
  Compiling: translation done ahead of time

Practice on Dev Console

  Output
    a=21;
    b=a*2;
    console.log(b);
   Where
      console.log(..) = print text (aka output) to user
      log(b) = Function (log=print to console)
      console. = object reference where log(..) is located
   Another Output ex
      alert(..);

  Input
    most common: form elements (txt boxes) for user to type into, Js then used to read values into programs variables.
    Alternatively: promt(..) function
      age = prompt("Please tell me your age:");
      console.log(age);
      29
     Where
      age = variable where input is stored
      console.log(age) = outputs variable stored in age
      prompt(..) = creates pop-up prompt to enter variable
      "Please tell me your age:" = message printed in popup

Operators
  Perform actions on variables and values
    * is multiplication
    = is assignment. takes right (source value) & put into variable on left (target variable), ex a=42

    Ex
      a=2;
      b=a+1;
     Where
      2 assigned to a value
      then get value of a add one
      get value 3 and store in b
       or: b is a-value plus one

    var = keyword, declares (creates) variables
      always declare by name before using.
      only need declare once for each 'scope'
        Ex. var a=20;
            a = a+1;
            a = a*2;
            console.log(a);   //42

  JS common operators
    - Assignment: =
    - Math: +(add), -(subt), *(mult), /(div)
    - Compound Assignment: +=, -=, *=, /= (combines math operation with assignment, ex 1 +=2 same as a=a+2)
    - Increment/Decrement: ++(increment), --(decrement), ex. a++ similar to a=a+1
    - Object Property Access: . as in console.log()
      objects = values holding other values at 'properties'
      propterties = specific namedlocations.
       Ex. obj.a = object value called 'obj' with property name 'a'
       properties also accesable as obj["a"]
    - Equality: ==(loose-equals), ===(strict-equals), !=(loose not-equals), !==(strict not-equals)
      Ex. a==b
    - Comparison: <(less than), >(greater than), <=(less than or loose-equals), >=(greater than or loose-equals)
      Ex. a<=b
    - Logical: &&(and), ||(or)
      Ex. a||b selects either a or b
    Operators used to express compound conditionals, ex. if either a or b is true.

Values & Types
  Types: Called 'primitive values' in JS. = different representations of value
  - string, number, boolean, arrays, objects, functions, etc
   Ex.
    Math: number
    Print value: string
    Decision: boolean (true/false)
   Literals = values included indirectly in source code
    String literals: surrouned by ""(block quotes) or ''(single quotes)
    Number literals ex; 42
    Boolean literals ex; true

  Converting Between Types
    Coersion/coercing = converting from a value type to string or vice versa
    Ex.
      var a="42";
      var b=Number(a);
      console.log(a);    // "42"
      console.log(b);   // 42
     Where
      Number(..) = explicit coercion from any type to 'number' type
       Implicit coercion = compare two values of different type

    Comparing "99.99" with 99.99, though similar = two different types. thus, 'loosely equal'
      Ex.
        If making  comparison "99.99"==99.99 JS will convert left (string) to 'number' equivalent, 99.99. Thus becomes 99.99==99.99, which is 'true'
    This is 'implicit coercion', which JS will sometimes do to help you. Can cause bugs, but not if mechanism properly understood/learned

Code Comments
  Inserted for user use. Comp ignores.

  Good code:
    - Has comments
    - not too many (ex. one per line = too much)
    - Explains why not what. How optional if confusing

  Styles:
    // Single line comment - for above single statement or end of line. everything on line after // is treated as comment, no restrictions.
      Ex.
        var a=42;    // 42 is the meaning of life
    /* Multi line comment */ - for several lines worth of explanation.
      Ex.
        /* The following value is used because it has bene shown that it answers every question in the univers. */
        var a=42;
    can appear anywhere on line, even in middle
      Ex.
        var a= /* arbitrary value*/ 42;
        console.log(a);  // 42

Variables
  Variables needed because operations change constantly over course of program. 'Variable' can vary over time as needed
  Variable is container

  Primary purpose: managing program State
    State: tracks changes to values as program runs.
  Alternate purpose: declare constant, if you do not mean for variable to change.

  - Static typing/Static enforcement: Some languages declare specific 'type' of value, ex. 'number' or 'string'. prevents unintended conversion
  - Weak typing/dynamic typing: emphasize types of values instead of variables. Allows variable to hold any kind of value type at any time.
  Benefit to flexibility. Single variable can represent a value regardless of what type form it takes at any given poing in program's logic flow. JS works like this.
    Ex.
      var amount=99.99;
      amount=amount*2;
      console.log(amount);    //199.98
      //convert 'amount' to a string, and add "$"+String(amount);
      amount="$"+String(amount);
      console.log(amount;)   // "$199.98"
     Where
      - variable starts out with number 99.99, then 99.99*2(188.98)
      - First console.log(..) Implicitly coerces number value to string
      - String(amount) Explicitly coerces number value to string, so 2nd console.log(..) statement does not coerce for printout

  Constants:
    - if value is not meant to change
    - declared at top of program, in one place
    - declare with capitals and _ between words
      Ex.
        var TAX_RATE=0.08;    //8% sales tax
        var amount = 99.99;
        amount=amount*2;
        amount=amount+(amount*TAX_RATE);
        console.log(amount);  // 215.9784
        console.log(amount.toFixed(2));   // "215.98"
       Where
        toFixed(..) = specify how many decimal places to round to
                      funtion to be accessed on 'number' values
        TAX_RATE = only constant by convention, nothing in program preventsvariable from being changed, but because in one place is easy to change for program should for ex tax increase, instead of searching out multiple instances throughout.

    ES6 includes new way to declare constants, using 'const' instead of 'var'
      Ex.
       const TAX_RATE=0.08;
       var amount=99.99;
    As useful as variables, but in addition prevents accidentally changing value somewhere else after initial setting.
      Ex. trying to assign different value to TAX_RATE after initial declaration would be rejected (failing with error in strict mode)

Blocks
  - Series of statements grouped together
  - Wrapped inside {..}
   Ex.
    var amount=99.99;
    // a general block
    {
      amount=amount*2;
      console.log(amount);    //199.98
    }
  - Typically attached to other control statement, ex 'if'
   Ex.
    var amount=99.99;
    //is amount big enough?
    if (amount>10) {     // <-- block attacked to 'if'
      amount=amount*2;
      console.log(amount);   // 199.98
    }
   Where
    {..} with its two statements (amount= and log)
    is attached to if(amount>10);
    thus statement only processed if conditional passes
  - block statement {..} does not need ; to conclude

Conditionals
  Decisions in your program
   Ex. If. = If this condition is true, do  following.
    var bank_balance=302.13;
    var amount=99.99;
    if (amount<bank_balance) {
        console.log("I want to buy this phone!");
    }
   Where
    (..) requires expression that can be either true or false. ie amount<bank_balance either is or isn't larger

  'Else' clause can be alternative if condition not true
   Ex.
    const ACCESSORY_PRICE=9.99;
    var bank_balance=302.13
    var amount=99.99;
    amount=amount*2;
    // can we afford the extra purchase?
    if (amount<bank_balance) {
        connsole.log("I'll take the accessory!");
        amount=amount+ACCESSORY_PRICE;
    }
    //otherwise
    else {
        console.log("No thanks.");
    }
   Where
    if amount<bank_balance is tue, "I'll take accessory!" will print and add 9.99 to amount variable.
    if false, else clause instructs to respond "No thanks" and amount remains unchanged.
  if statement expects boolean value, if given something that is not, will coerce

  JS defines list of values considered either "truthy" or "falsy"
    falsy: when coerced to boolean, become false. incl. 0 and ""
    truthy: if not falsy is automatically truthy.becomes true when coerced to boolean. incl 99.99 and "free"

  Other conditionals:
    - switch: shorthand for series of if..else statements
    Loops use conditional to determine if loop should continue or stop

Loops
  Job is to keep repeating set of actions as long as condition holds
  Includes test condition as well as block{..}
    Iteration = each time loop block executes
     Ex.
      while (numOfCustomers>0) {
          console.log("How may I help you?");
          //help the customer...
          numOfCustomers=numOfCustomers-1;
      }
      //versus:
      do {
          console.log("How may I help you?");
          //helt the customer...
          numOfCustomers=numOfCustomers=1;
      } while(numOfcustomers>0)
     Where
      Only difference is whether conditional is tested before or after first iteration. (while)/(do..while)
      In either case if conditional tests false next iteration will not run.
      If initial condition false, 'while' loop will never run but do..while loop will run just first time.

    Languages almost always count from 0 up, not 1. Replace value 0 with i when wanting to count numbers

    conditional tested on each iteration, as if there is implied 'if' statement in loop

    Break statement used to stop loop.
      Ex.
        var i=0;
        // a 'while true' loop will run forever, right?
        while (true) {
            //stop the loop?
            if ((i<=9) ===false) {
                break;
          }
          console.log(i);i=i+1;
        }
        // 0 1 2 3 4 5 6 7 8 9
       ^not practical approach

    while or do..while can accomplish task manually,
    'for' loop is made for this purpose
      Ex.
        for (var i=0; i<=9; i=i+1) {
            console.log(i);
        }
        // 0 1 2 3 4 5 6 7 8 9
       Where
        i<=9 true for 1st 10 iterations (i values 0 through 9)
        becomes false  once i=10
      for loop 3 clauses
        - initial clause (var i=0)
        - conditional test clause (i<=9)
        - update clause (i=i+1)
      Thus 'for' more compact & easier to understand & write
     Other specialized loop forms exist to iterate over specific values, ex. properties of object, but "loop until condition fails" holds for all loops regardless of form.

Functions
  Section of code that can be 'called' to be repeated. aka reusable piece
    Ex.
      fucntion printAmount() {
          console.log(amount.toFixed(2));
      }
      var amount=99.99;
      printAmount();   // "99.99"
      amount=amount*2;
      printAmount();   // "199.98"
    or
      function printAmount(amt) {
          console.log(amt.toFixed(2));
      }
      function formatAmount() {
          return "$"+amount.toFixed(2));
      }
      var amount=99.99;
      printAmount(amount*2);    //"199.98"
      amount=formatAmount();
      console.log(amount);      //"$99.99"
     Where
      function printAmount(..) takes parameter called 'amt'
      function formatAmount() returns value
        -can also be combined
    Parameter:
      of a function. ex. amt in printAmount(amt)

  Used for code that will be called multiple times
  or useful for organizing related bits of code in named locations, even if only called once.
    Ex.
      const TAX_RATE=0.08;
      function calculateFinalPurchaseAmount(amt) {
      //calculate the new amount with the tax
      amt=amt+(amt*TAX_RATE);
      return amt;
      }
      var amount=99.99;
      amount=calculatePurchaseAmount(amount);
      console.log(amount.toFixed(2));
     Where
      calculateFinalPurchaseAmount(..) only called once, but makes logic of final statement (amount=calculateFinal..) cleaner

Scope
  aka Lexical Scope
  - in JS all functions gets own scope
  - = Collection of variables + rules for how said variables accessed by name.
  - Only code inside function can access said function's 'scoped' variables
  - Variable name has to be unique within same scope, but same name can appear in different scopes
    Ex.
      function one() {
      //this 'a' only belongs to the 'one()' function
      var a=1;
      console.log(a);
      }
      function two() {
      //this 'a' only belongs to the 'two()' function
      var a=2;
      console.log(a);
      }
      one();    // 1
      two();    // 2
     Where
      Can't access a=1 in function two(); it's scope is only within {} thus its a=2 only

    - Scope can be nested in another scope
      where nested scope can access code inside either scope
      Ex.
        function outer() {
            var a=1;
            function inner() {
                var b=2;
                //we can access both 'a' and 'b' here
                console.log(a+b);  //3
        }
            inner();
            //we can only access 'a' here
            console.log(a);    //1
        }
        outer();
  - code in one scope can access variables in either scope outside of it
      Thus
        code inside inner() has access to both a and b
        code inside outer() only has access to a, not b because b variable only inside inner()
      Ex.
        const TAX_RATE=0.08;
        function calculateFinalPurchaseAmount(amt) {
        // calculate the new amoutn with the tax
        amt=amt+(amt*TAX_RATE);
        // return the new amount
        return amt;
        }
       Where
        TAX_RATE constant (var) is accesable from inside calculateFinalPurchaseAmount(..) funnction, even though unpassed

Review
  Operators: perform actions on values
  Values&types: to perform different kinds of actions
  Variables: store data (state) during execution.
  Conditionals: make decisions
  loops: repeat tasks
  functions: organize into logical and reusable chunks.

Code comments for writing more readable, understandable and useable code.

------------------------------------------------------------------------

# Chapter 2 - Into JS
 Overview of topics covered in rest of YDKJS books

# Values & Types

JS has typed values, not variables.

  Built-in types:
      - string   ---  a="Hello world";
      - number   ---  a=42;
      - boolean   ---  a=true;
      - null & undefined   ---  var a;
      - object   ---  a={b:"c"};
      - symbol   ---

  ```typeof``` operator can examine value and tell you which type it is.
  - answer always in 'string'
  - ``typeof a`` does not return type of a but rather type of variable
    held by a.
  - only values have types in JS, variables just container.
  - ``a=null;  typeof a; returns "object" --longstanding bug now commonly
    employed.
  - "Undefined" type reached in variety of ways, including undeclared
    variable, functions that return no value, or usage of ``void`` operator



Objects
 Refers to compound value where properties (named locations) can be set, each holding own values of any type.
  Ex.
    ```javascript
    var obj = {
      a: "hello world",
      b: 42,
      c: true
    };
    obj.a;  //"hello world"
    obj.b;  //42
    obj.c;  //true
    obj["a"]; //"hello world"
    obj["b"]; //42
    obj["c"]; //true
    ```
   Where
    obj
    +----++----++----++----++----++----+
    | a: "hello world"| b: 42 | c: true |
    +----++----++----++----++----++----+

  - Properties accessed by dot notation (obj.a) or bracket notation (obb["a"]).
  - Dot notation preferred for brevity and readability.

 [Bracket] notation:
  - Useful if property name contains special characters Ex.
      obj["hello world"] -- aka keys (properties accessed by bracket not).
  - requires either variable or string 'literal', wrapped in ".." or '..'
  - useful for accessing property/key but name is stored in another var
      Ex.
        ```javascript
        var obj = {
          a: "hello world",
          b: 42
        };
        var b = "a";
        obj[b];      //"hello world"
        obj["b"];   // 42
        ```
  Other value types:
    - array
    - functions
      ^ More correctly a sub-type of 'object' type.

  Array:
    'object' that holds values not in keys but numerically indexed positions
      Ex.
        ```javascript
        var arr = [
        "hello word",
        42,
        true
        ];
        arr[0];        // "hello world"
        arr[1];        // 42
        arr[2];        // true
        arr.length;    // "object"
        typeof arr;    // "object"
        ```
       Where
         arr
         +----++----++----++----++----++----+
         | 0: "hello world"| 1: 42 | 2: true |
         +----++----++----++----++----++----+
     - special objects, can also have properties, incl updated 'length'
      property.
    - Array can be used as normal object with own name properties,
    - or use `object` and give nomeric properties (0,1,) <- improper usage
    - best use: for numerically positioned values, vs `object` for named properties.

  Functions:
     ```javascript
     function foo() {
           return 42;
     }
     foo.bar = "hello world";

     typeof foo;    // "function"
     typeof foo();  // "number"
     typeof foo.bar; // "string"
     ```
    Where
     implies it can have properties, but typically will only use function obj properties in limited cases



Built-In Type Methods
  ```javascript
  var a = "hello world";
  var b = 3.14159;
  a.length;        // 11
  a.toUpperCase(); //"HELLO WORLD"
  b.toFixed(4);    // "3.1416"
  ```
 Where
  "hello world" is primitive `string` type, wrapped by native `String` object created through toUpperCase()
  string value wrapped by String object, number value by Number object, etc



Comparing Values
  Two types:
    - Equality
    - Inequality
  - result is boolean, regardless of value types compared

  Coercion:
    - explicit - can see from code conversion will take place
      Ex.
        ```javascript
        var a = "42";
        var b = Number(a);
        a;   // "42"
        b; // 42 -- the number
        ```
    - implicit - non-obvious side-effect of operation
      Ex.
        ```javascript
        var a = "42";
        var b = a * 1;  //"42" implicitly coerced to 42
        a;    // "42"
        b;   // 42 -- the number
        ```
    Truthy & Falsy
      - when non-boolean value is coerced to boolean, becomes either truthy or falsy
      Falsy:
        - "" (empty string)
        - 0, -0. NaN (invaid number)
        - null, undefined
        - false
      Truthy:
        - any value not 'falsy'
        - "hello"
        - 42
        - true
        - [], [1, "2", 3] (arrays)
        - {}, {a: 42} (objects)
        - function.foo() {..} (functions)
      Only relevant when coerced to boolean

  Equality
    Four equality operators
      - ==     - checks for value equality with coercion allowed
      - ===    - checks value equality without coercion allowed (strict eq)
        Ex.
          ```javascript
          var a = "42";
          var b = 42;
          a == b;  // true
          a === b; // false
          ```
         Where
          a==b - JS notices types not match, coerces one or both values unntil types match, then value equality checked.
          a===b - false because coercion not allowed, different types =/=
      - !=   pairs with ==    -: ! not equal
      - !==  pairs with ===   -:
     non-equality =/= inequality

      Choosing == or ===
        - if either value/side in comparison could be true or false value, use ===
        - if either value in comparison could be of these specific values (0, "", [] -- empty array), use ===
        - in all other cases, use ==
       These rules require you to think critically of what values can come through variables that get compared for equality.
        - Certain of vuales and == is safe, use it.
        - If uncertain, use ===
       Same applies for !=, !==
       For non- primitive values (obj., function, array) take special note of ==, ===. These values held by reference, comparisons simply check if references match, not anything involving underlying values.
        Ex. arrays default coerced to string by simply joining all values with commas in-between. two arrays with same contents is not ==
          ```javascript
          var a = [1,2,3];
          var b = [1,2,3];
          var c = "1,2,3"
          a == c;  // true
          b == c;  // true
          a == b;  // false
          ```
  Inequality
    Relational comparison
    - <
    - >
    - <=
    - >=
    Usually used with comparable values, like numbers.
    String values also comparable for inequality, using alphabetical rules
      Ex. "bar" < "foo"
    Coercion: similar rules as == apply. no strict inequality that disallows coersion.
      Ex.
        ```javascript
        var a = 41;
        var b = "42";
        var c = "43";
        a < b;  // true
        b < c;  // true
        ```
       Where
        if number and string, coerced to number
        if both string, comparison lexicographical (alphabetical)
      When one value cannot be made into valid number
        Ex.
        ```javascript
        var a = 42;
        var b = "foo";
        a < b;   // false
        a > b;   // false
        a == b;  // false
        ```
       Where
        b is coerced to 'invalid number value' NaN
        NaN neither > nor < any other value
        == fails because 42 == NaN


Variables

  In JS, variable names must be 'valid identifiers'
  For ASCII:
    - starts with a-z, A-Z, $, _, plus numerals 0-9

  Same rules apply to property name as variable identifier.
  Certain words ok for property names but not variables. 'reserve words'
  Reserve words incl JS keywords
    - for, in, if, etc
    - null, true, false

  Function Scopes
    var keyword to declare variable that will belong to current function scope, or global scope if at top level outside function

    Hoisting:
      Where var appears inside scope, declaration accepted to belong to entire scope and accessable throughout.
      Thus
      Hoisting: when var declaration conceptually moved to top of enclosing scope.
        Ex.
          ```javascript
          var a = 2;
          foo();     // works because 'foo()'
                     // declaration is "hoisted"
          function foo() {
            a =3;
            console.log(a);   // 3
            var a;           // declaration is "hoisted"
          }                     // to the top of 'foo()'
          console.log(a);    // 2
          ```
        Not a good idea to rely on variable hoisting to use var earlier in its scope than its var declaration appears. More common to use hoisted function declarations, as we do with foo() call appearing before its formal declaration

      Nested Scopes:
       When var declared accessable anywhere in that scope as well as any lower/inner scopes
        Ex.
         ```javascript
         function foo() {
           var a=1;
           function bar() {
             var b=2;
             function baz() {
               var c=3;
               console.log(a, b, c);  //1 2 3
             }
             baz();
             console.log(a,b)   // 1 2
           }
           bar();
           console.log(a);     // 1
         }
         foo();
         ```
         Where
         c not available inside bar() because declared only inside inner baz()
         b not available to foo()

       If attempting to access variable's value in scope where not available, get ReferenceError.
       If setting variable that has not been declared, you will create either top-level global scope, or get error, depending on strict mode
        Ex.
         ```javascript
         function foo() {
           a = 1;  // 'a' not formally declared
         }
         foo();
         a;       // 1 -- oops, auto global variable
         ```
         Where
         Bad practice. always formally declare variables

        Variables can be declared to belong to individual blocks (pairs of {..}) in  addition to declaring them at function level, using 'let' keyword. Scoping rules behave roughly the same as with functions
          Ex.
           ```javascript
           function foo(){
             var a=1;
             if (a>=1) {
               let b=2;
               while (b<5) {
                 let c=b*2;
                 b++;
                 console.log(a+c)
               }
             }
           }
           foo();    // 5 7 6
           ```
           Where
           Because 'let' instead of 'var', 'b' belongs only to if statement and not whole foo() scope
           c belongs to 'while' loop
          Block scoping useful for managing variable scopes in more fine-grained fashion. makes code easier to maintain


Conditionals
  Other connditional mechanisms beyond 'if'
    Ex. if..else..if statements
      ```javascript
      if (a == 2) {
        // do something
      }
      else if (a == 10) {
        // do another thing
      }
      else if (a == 42) {
        // do another thing
      }
      else {
        // fallback to here
      }
      ```
     Where
      Structure works but is verbose because a must be specified for each test case.

    Consider 'switch' statement:
      Ex.
        ```javascript
        switch (a) {
          case 2:
            // do something
            break;
          case 10:
            // do another thing
            break;
          case 42:
            // do another thing
            break;
          default:
            // fallback to here
        }
        ```
       Where
        'break' is important if you want only statements in one 'case' to run.
      omitting 'break' from 'case', execution continues with next case's statement regardless of that case matching. aka "fall through"
        Ex.
          ```javascript
          switch (a) {
            case 2:
            case 10:
              // some cool stuff
              break;
            case 42:
              // other stuff
              break;
            default:
              // fallback
          }
          ```
         Where
          if 'a' either 2 or 10, it will execute 'some cool stuff' statements

        conditional operator, aka ternary operator.
         more concise form of single if..else statements
          Ex.
            ```javascript
            var a = 42;
            var b = (a > 41) ? "hello" : "world";
            // similar to:
            // if (a > 41) {
            //    b = "hello"
            // }
            // else {
            // b = "world";
            // }
            ```
           Where
            test expression, 'a>41' evaluates true, first clause "hello" results, otherwise second clause "world" results, and result assigned to 'b'
          Conditional operator doesn't have to be used in assignment, but is most common.


Strict Mode
  Tightens rules for certain behaviours.
  Restrictions seen as keeping code to safer and more appropriate set of guidelines.
  Adhering to strict mode makes engine more optimizable by engine
  - Use for all programs
  - can opt in to strict mode for individual funnction or entire file dependant on where strict mode pragma placed.
    Ex.
      ```javascript
      function foo() {
        "use strict";
        // code here is strict mode
        function bar() {
          // code here is strict mode
        }
      }
      // code here not strict mode
    Compared
      "use strict";
      function foo() {
        // this code strict
        function bar() {
          // this code strict
        }
      }
      // this code strict
    ```
  One key difference: disallows implicit auto-global declaration from omitting 'var'
    Ex.
      ```javascript
      function foo() {
        "use strict"  // turn on strict mode
        a = 1;            // 'var' missing, ReferenceError
      }
      foo();
      ```
    Temptation will be to avoid strict mode due to errors, but if errors occur is indication that there are issues in program, not optimal.

  Strict mode will keep code on safer path, make more optimizable, but also future direction of language.


Functions As Values
 Funnction primary function of Scope
  Function Ex.
    ```javascript
    function foo() {
      // ..
    }

   Where
    foo is variable in outer enclosing scope, given reference to function being declared.
    'function' itself is value, just like 42, [1,2,3] etc
    ```
  Not only can value(argument) be passed to function, but function itself can be a value that is assigned to variables, or passed to or returned from other functions.
  Function value to be thought of as expression, much like any other value/expression.
    Ex.
      ```javascript
      var foo = function() {
        // ..
      };
      var x = function bar() {
        //..
      };
     Where
      1st function expression assigned to 'foo' var is called 'anonymous' bc has no 'name'
      2nd function expression is 'named' 'bar', even as reference to it also assigned 'x' variable.
      ```
    'Named function expressions' generally more preferable but 'anonymous function expressions' still common.

  Immediately Invoked Function Expressions (IIFEs)
    Above function executed if added foo() or x()
    Immediately invoked funnfction expression (IIFE): alternate way to execute function expression
      Ex.
        ```javascript
        (function IIFE(){
          console.log("Hello!");
        })();
        // "Hello!"
       Where
        outer (..) surrounding (function IIFE(){..}) function expression is just nuance of JS grammar needed to prevent treatment as normal function declaration.
        Final () on end of expression is what execures function expression referenced immediately before it.
        ```
      Consider similarities of 'foo' and 'IIFE'
        Ex.
          ```javascript
          function foo() {..}
          // 'foo' function reference expression, then '()' executes it
          foo();
          //'IIFE' function expression, then '()' executes it
          (function IIFE(){..})();
         Where
          listing (function IIFE(){..}) before executing () is same as including 'foo' before executing (); in both cases function reference executed with () immediately after it.
          ```
      Because IIFE just a function, and functions create variable 'scope', using IIFE often used to declare variables that won't affect surrounding code outside IIFE
        Ex.
          ```javascript
          var a = 42;
          (function IIFE(){
            var a = 10;
            console.log(a);   // 10
          })();
          console.log(a);    // 42
          ```
      IIFEs can also have return values:
        Ex.
          ```javascript
          var x = (function IIFE(){
                   return 42;
          })();
          x;    // 42
         Where
          42 value gets return-ed from IIFE-named function being executed and then assigned to 'x'
          ```
  Closure
   Way to 'remember' and continue to access a function's scope (variables) even once function has finished running
    Ex.
      ```javascript
      function makeAdder(x) {
        /// parameter 'x' is inner variable
        // inner function 'add()' uses 'x', so it has "closure" over it
        function add(y) {
          return y + x;
        };
        return add;
      }
     Where
      reference to innder add(..) function that gets returned with each call to outer makeAdder(..) is able to remember whatever x value was passed in to makeAdder(..)
    Ex.
      // 'plusOne' gets reference to inner 'add(..)' function with closure over 'x' parameter of outer 'makeAdder(..)'
      var plusOne = makeAdder(1);
      // 'plusTen' gets reference to inner 'add(..)' function with closure over the 'x' parameter of outer 'makeAdder(..)'
      var plusTen = makeAdder(10);

      plusOne(3);       // 4 <-- 1 + 3
      plusOne(41);      // 42 <-- 1 + 41
      plusTen(13);      // 23 <-- 10 + 13
     Where
      1. When calling makeAdder(1), get back reference to inner add(..) that remembers 'x' as 1. function called plusOne(..)
      2. When calling makeAdder(10), get back another reference to inner add(..) that remembers 'x' as 10. function called plusTen(..)
      3. When calling plusOne(3), adds 3 (inner 'y') to 1 (remembered 'x'), and 4 is result
      4. When callling plusTen(13), adds 13 (inner 'y') to 10 (remembered 'x') and 23 is result
      ```

    Modules
     - module pattern most common usage of closure.
     - lets you define private implementation details (variables, functions) hidden from outside world, incl public API that -is- accessible from outside
      Ex.
        ```javascript
        function User(){
          var username, password;
          function doLogin(user,pw) {
            username = user;
            password = pw;
            // do the rest of the login work
          }
          var publicAPI = {
            login: doLogin
          };
          return publicAPI;
        }
        // create a 'User' module instance
        var fred = User();
        fred.login("fred", "12Battery34!");
       Where
        User() function serves as outer scope holding variables 'username' and 'password', incl inner doLogin() function
        all private inner details of User module not accessable from outside world.
        - executing User() creates 'instance' of User module, whole new scope is created, thus new copy of each of inner variables/functions. instance assigned 'fred'. if ran again, new instance entirely seperate from 'fred' would be created.
        - inner doLogin() function has closure over 'username' and 'password', thus retains access even after User() finishes running.
         would normally think variables like 'username' and 'password' would have gone away but they do not because there is closure in login() function keeping them alive.
         is why fred.login(..) can be called, same as calling inner doLogin(..) -- can still access 'username' and 'password' inner variables.
        ```


'this' Identifier
  - not same mechanism as "object-orientated patterns"
  - if function has 'this' reference inside, that 'this' reference usually points to an 'object'. which object is being pointed to depends on how function was called.
  - 'this' does not refer to the function itself - common misconception.
    Ex.
      ```javascript
      function foo() {
        console.log(this.bar);
      }
      var bar = "global";
      var obj1 = {
        bar: "obj1"
        foo: foo
      };
      var obj2 = {
        bar: "obj2"
      };
      // ----------
      foo();        // "global"
      obj1.foo();  // "obj1"
      foo.call(obj2); // "obj2"
      new foo();     // undefined
     Where
      'this' gets set according to 4 rules
        1. foo() sets 'this' to global object in non-strict mode -- in strict mode, 'this' would be 'undefined' and would receive error in accessing 'bar' property -- so "global" is value found in this.bar.
        2. obj1.foo() sets 'this' to 'obj1' object
        3. foo.call(obj2) sets 'this' to 'onj2' object
        4. new foo() sets 'this' to brand new empty object
      ```
    to understand what 'this' points to, have to examine how function in question was called. It will be one of those 4 ways shown
```

Prototypes
  - When referencing property on object that does not exist, JS automatically uses object's internal prototype reference to find another object to look for property on. aka fallback if property is missing
  - Internal prototype reference linkage from one object to its fallback happens at time object is created.
    Ex. Illustrated best with utility Object.create(..)
      ```javascript
      var foo = {
        a: 42
      };
      //create 'bar' and link to 'foo'
      var bar = Object.create(foo);
      bar.b = "hello world";
      bar.b;         // "hello world"
      bar.a;        // 42 <-- delegated to 'foo'
      ```
    'foo' and 'bar' objects Illustrated
     foo
      +------+
      | a:42 |
      +------+
         ^
         | prototype link
     bar |
      +-----------------+
      | b:"hello world" |
      +-----------------+
     Where
      'a' property does not actually exist on 'bar' object, but because 'bar' prototype-linked to 'foo', JS auto fallbacks to looking for 'a'  on 'foo' object.
    - Most common use of feature is emulate/fake "class" mechanism with "inheritance"
    - More natural way of applying prototypes is pattern called "behaviour delegation", where linked objects intentionally designed to be able to 'delegate' from one to other for parts of needed behaviour.


Old & New
  Polyfilling & Transpiling: techniques for dealing with legacy browsers or non-support of newer JS technology.

  Polyfilling
    Invented term that means taking definition of newer feature and producing piece of code that is equivalent in behaviour but able to run on older JS environment.
      Ex. ES6 defines utility called 'Number.isNaN(..)' to provide accurate check for NaN values, deprecating original isNaN(..) utility. Easily polyfilled by:
        ```javascript
        if (!Number.isNaN) {
          Number.isNaN = function isNaN(x) {
            return x !== x;
          };
        }
       Where
        if statement guards against applying polyfill definition in ES6 browsers where it already exists. If not present, we define Number.isNaN(..)
        ```
      This check we do takes advantage of quirk with NaN values, that they're only value in entire language that is not equal to itself. aka NaN value 'x !== x' is 'true'

      Not all new features fully polyfillable, some small deviations. Should be careful impplementing polyfill yourself, to make sure specifications are adhered to strict as possible. Or use vetted source.

  Transpiling
    No way to polyfill new syntax added to language. get error as unrecognized/invalid
    Better option to use tool to convert newer code into older code equivalent, aka 'transpiling'. means transforming+Compiling
    Source code essentually authored in new syntax, but what is deployed to browser is transpiled code in old syntax form.
    Transpiler typically inserted into build process, similar to code linter or minifier.

    Why transpile and not write older code directly?
      - new syntax designed to make code more readable and maintainable. older versions more convoluted.
      - If transpiling for old but serve new syntax for newest browsers allows taking advantage of browser performance optimization with new syntax. browser makers also have more real-world code to test implementation + optimization on
      - Using new syntax earlier allows testing more robustly in real world, providing earlier feedback to JS committee. If issues found early, can be changed/fixed before language design mistakes become permanent.

    Ex. "default parameter values"
      ```javascript
      function foo(a = 2) {
        console.log( a );
      }
      foo();     // 2
      foo(42);  // 42
     Transpiler for older:
      function foo() {
        var a=argumens[0] !== (void 0) ? arguments[0] : 2;
        console.log(a);
      }
     Where
      it checks to see if arguments[0] value is void 0 (aka 'undefined'), and provides default 2 value, otherwise assigns whatever is passed.
      In addition to being able to use nicer syntax in older browsers, looking at transpiled code explains intended behaviour more clearly.
      'undefined' only value that cant get explicitly passed in for default-value parameter, but transpiled code makes this clear.
      ```
    transpilers should be thought of as standard part of JS development ecosystem and process. JS will always evolve, faster and faster. syntax added every few months
    If transpiler used by default, always able to make switch to newer syntax whenever useful, rather than awaiting browsers.


Non-JavaScript
  Most JS written to run + interact with environments like browsers
  Good chunk of what is written in code not directly controlled by JS
    Ex. DOM API
      ```javascript
      ```
      var el = document.getElementByID("foo");
     Where
      'document' variable exists as global variable when code running in browser.
      Not provided by JS engine, nor controlled by JS specification.
      Takes form of something that looks like normal JS 'object', but is not.
      Is special 'object', called "host objet"
      getElementById(..) method on 'document' looks like normal JS function, but is thinly exposed interface to built-in method provided by the DOM of browser. DOM behaviour implemented in C/C++ typically.


    Ex. 2. input/output (I/O)
      alert(..) pops up message box in user window.
      alert(..) provided to JS program by browser, not by JS engine itself.
      Call made sends message to browser internals and it handles drawing and displaying message box.
    Ex. 3 console.log(..)
      browser provides such mechanisms and hooks up to dev tools
    This book focuses on JS language, thus not much coverage of non-JS JS mechanisms, but be aware of them.


Review
  First step to learning JS programming is get basic understanding of core mechanisms, ex. values, types, function closures, this, prototypes


-------------------------------------------------------------------

# CHAPTER 3

Scopes & Closures
  Debunks that JS is 'interpreted language' and thus not compiled
  JS compiles code right before (sometimes during) execution.

  Must understand how JS compiler approaches code to understand how it deals with variable and function declarations.
  JS variable scope management: 'hoisting'

  Understanding "lexical scope" critical for understanding closure on last chapter of book.
  Closure most important concept in JS, but can't understand without understanding scope.

  Module pattern: most prevalent code organization pattern in JS, deep understanding should be high priority.


this & Object Prototypes
  persistent mistruth is that 'this' keyword refers to function it appears in.

  'this' keyword dynamically bound based on how functions in question is executed, and there are 4 simple rules to understand and determine 'this' binding.

  Closely related to 'this' keyword is object prototypemechanism, which his look-up chain for properties, similar to how lexical scope vars are found. Wrapped up in this another big miscue about JS: ide of emulating (fake) classes and inheritance (so-called "prototypal")

  Bringing class and inheritence design pattern thinking to JS is bad, because while syntax may trick into thinking there are something like classes present, prototype mechanism is fundamentally opposite this behaviour.

  Issue is whether to ifnore mismatch and pretend you're implementing "inheritance" or whether is more appropriate to learn and embrace how object prototype system works. latter is named "behaviour delegation"

  More than syntactic preference. Delegation different and more powerful design pattern that replaces need to design with classes and inheritance. <-- not popular opinion, but true.

  Delegation vs inheritance claims comes from desire to see true capability of language properly leveraged, confusion wiped away.


Types & grammar
  Tackled type coercion. Lots of confusion around implicit coercion, often seen as bad and to be avoided, even called 'flaw'.

  After building understanding of how types and values work ch1-3, Ch4 explains how coercion works. Much of it makes sense if understood.

  Coercion not only sensible and learnable but very useful and underestimated tool that -should- be used. Not only works, but makes code better.


Async & Performance
  First 3 titles focuses on core mechanics of language, fourth branches out into cover patterns on top of language machanics for managing asynchronous programming.
  Asynchrony not only critical to performance but incresingly critical factor in writability and maintainability.

  Starts with clearing up terminology and concept confusion around 'async', 'parallel', 'concurrent' + explains how it does and does not apply to JS.

  Examine callbacks as primary method of asynchrony, but show it is isufficient for modern demands of async programming.
  Identify 2 major deficiencies of callbacks-only coding: Inversion of Control (IoC) trust loss and lack of linear reason-ability.
  To address, ES6 introduces 2 new mechanisms (and patterns): promises and generators

  Promises: time-dependent wrapper around "future value", lets you reason about and compose regardless of if value is ready yet or not. Efficiently solves IoC trust issues by routing callbacks through trustable and compsable promise mechanism

  Generators: time-independent wrapper around "future value", where generator can be paused at 'yield' points and resumed asynchronously later. Pause-and-resume capability enables synchronous, sequential-looking code in generator to be processed asynchronously behind scenes. Addresses non-linear, non-local-jump confusions of calllbacks and thereby make asynchronous code sunc-looking so as to be more reason-able.

  Combination of promises and generators that yields most effective asynchronous coding pattern to date in JS. Much future sophistication of asynchrony coming in ES7+ will be built on this foundation. Better get comfortable.

  Promises and generators about expressing patterns that let programs run more concurrenly and thus get more processing accomplished in shorter  period. JS also has many more facets of perf. opt. worth exploring.

  Ch5 delves into topics like program parallelism and Web Workers and data parallelism with SIMD, as well as low-level optimization techniques like ASM.js.
  Ch6 takes look at perf. opt. from perspective of proper benchmarking techniques, incl what kinds of performance to worry about or ignore.

  Writing effective JS = writing code that breaks and constrains barriers of being run dynamically in wide range of browsers and other environments. Requires intricate + detailed planning and effort to take from "it works" to "it works well"

  Async & Performance designed to give all tools and skills needed to write reasonable and performant JS code.

ES6 & Beyond
  JS never going to stop evolving, and rate of evolution increasing rapidly. Will never truly know JS

  title dedicated to both short- and mid-term versions of where language is headed, not just known stuff like ES6, but beyond.
  Book embraces

  ES6&Beyond starts by dividing concrete stuff from ES6 landscape into several key categories, incl new syntax, new data structures (collections) and new processing capabilities and API's. Cover each of these ES6 features in varying levels of detail incl reviewing details that are touched on in other books of series.

  Exciting ES6 things to look forward to reading: destructuring, default parameter values, symbols, concise methods, computed properties, arrow functions, block scoping, promises, generators, iterators, modules, proxies, weakmaps, etc etc.

  First part of book is roadmap for all the stuff you need to learn to get ready for new and improved JS you'll be writing and exploring over next couple of years.
  Latter part of book briefly glances at things we can likely expect to see in near future of JS. post-ES6, JS likely to evolve feature by feature rather than version by version, can expect to see near-future things coming sooner than imagined.
