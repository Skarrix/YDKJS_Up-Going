#Ch1
quick overview of what you'll want to learn+practice to get into programming

Code
  Language=syntax. code=set of instructions in a given language.
  Saved in txt file.

  Statement: group of words/numbers/operators performing specific task.
             Conclude with ;
             Made up of 1 or more Expressions
  a=b*2; where a/b = variables, 2 = literal value (stands alone), =/* = operators.

  Variables: holds values

  Operators: Performs actions with values and variables

  Expressions: a reference to variable or value, or set thereof, combined    with         operators.
              For a = b * 2
              2 = literal value expression
              b = variable expression (retrieve current value)
              b * 2 = arithmetic expression (execute multiplication), also 'expression statement' (stands alone, not useful bc does nothing with output)
              a = b * 2 = assignment expression (assign result of b*2 exp to variable a)
              alert( a ); = call expression statement

Compiler/Interpreter: runs/executes/compiles code into commands
  Interpreting code: top to bottom, line by line, each time program runs
  Compiling: translation done ahead of time

Practice on Dev Console

  Output
    a=21;
    b=a*2;
    console.log(b);
   Where
      console.log(..) = print text (aka output) to user
      log(b) = Function (log=print to console)
      console. = object reference where log(..) is located
   Another Output ex
      alert(..);

  Input
    most common: form elements (txt boxes) for user to type into, Js then used to read values into programs variables.
    Alternatively: promt(..) function
      age = prompt("Please tell me your age:");
      console.log(age);
      29
     Where
      age = variable where input is stored
      console.log(age) = outputs variable stored in age
      prompt(..) = creates pop-up prompt to enter variable
      "Please tell me your age:" = message printed in popup

Operators
  Perform actions on variables and values
    * is multiplication
    = is assignment. takes right (source value) & put into variable on left (target variable), ex a=42

    Ex
      a=2;
      b=a+1;
     Where
      2 assigned to a value
      then get value of a add one
      get value 3 and store in b
       or: b is a-value plus one

    var = keyword, declares (creates) variables
      always declare by name before using.
      only need declare once for each 'scope'
        Ex. var a=20;
            a = a+1;
            a = a*2;
            console.log(a);   //42

  JS common operators
    - Assignment: =
    - Math: +(add), -(subt), *(mult), /(div)
    - Compound Assignment: +=, -=, *=, /= (combines math operation with assignment, ex 1 +=2 same as a=a+2)
    - Increment/Decrement: ++(increment), --(decrement), ex. a++ similar to a=a+1
    - Object Property Access: . as in console.log()
      objects = values holding other values at 'properties'
      propterties = specific namedlocations.
       Ex. obj.a = object value called 'obj' with property name 'a'
       properties also accesable as obj["a"]
    - Equality: ==(loose-equals), ===(strict-equals), !=(loose not-equals), !==(strict not-equals)
      Ex. a==b
    - Comparison: <(less than), >(greater than), <=(less than or loose-equals), >=(greater than or loose-equals)
      Ex. a<=b
    - Logical: &&(and), ||(or)
      Ex. a||b selects either a or b
    Operators used to express compound conditionals, ex. if either a or b is true.

Values & Types
  Types: Called 'primitive values' in JS. = different representations of value
  - string, number, boolean, arrays, objects, functions, etc
   Ex.
    Math: number
    Print value: string
    Decision: boolean (true/false)
   Literals = values included indirectly in source code
    String literals: surrouned by ""(block quotes) or ''(single quotes)
    Number literals ex; 42
    Boolean literals ex; true

  Converting Between Types
    Coersion/coercing = converting from a value type to string or vice versa
    Ex.
      var a="42";
      var b=Number(a);
      console.log(a);    // "42"
      console.log(b);   // 42
     Where
      Number(..) = explicit coercion from any type to 'number' type
       Implicit coercion = compare two values of different type

    Comparing "99.99" with 99.99, though similar = two different types. thus, 'loosely equal'
      Ex.
        If making  comparison "99.99"==99.99 JS will convert left (string) to 'number' equivalent, 99.99. Thus becomes 99.99==99.99, which is 'true'
    This is 'implicit coercion', which JS will sometimes do to help you. Can cause bugs, but not if mechanism properly understood/learned

Code Comments
  Inserted for user use. Comp ignores.

  Good code:
    - Has comments
    - not too many (ex. one per line = too much)
    - Explains why not what. How optional if confusing

  Styles:
    // Single line comment - for above single statement or end of line. everything on line after // is treated as comment, no restrictions.
      Ex.
        var a=42;    // 42 is the meaning of life
    /* Multi line comment */ - for several lines worth of explanation.
      Ex.
        /* The following value is used because it has bene shown that it answers every question in the univers. */
        var a=42;
    can appear anywhere on line, even in middle
      Ex.
        var a= /* arbitrary value*/ 42;
        console.log(a);  // 42

Variables
  Variables needed because operations change constantly over course of program. 'Variable' can vary over time as needed
  Variable is container

  Primary purpose: managing program State
    State: tracks changes to values as program runs.
  Alternate purpose: declare constant, if you do not mean for variable to change.

  - Static typing/Static enforcement: Some languages declare specific 'type' of value, ex. 'number' or 'string'. prevents unintended conversion
  - Weak typing/dynamic typing: emphasize types of values instead of variables. Allows variable to hold any kind of value type at any time.
  Benefit to flexibility. Single variable can represent a value regardless of what type form it takes at any given poing in program's logic flow. JS works like this.
    Ex.
      var amount=99.99;
      amount=amount*2;
      console.log(amount);    //199.98
      //convert 'amount' to a string, and add "$"+String(amount);
      amount="$"+String(amount);
      console.log(amount;)   // "$199.98"
     Where
      - variable starts out with number 99.99, then 99.99*2(188.98)
      - First console.log(..) Implicitly coerces number value to string
      - String(amount) Explicitly coerces number value to string, so 2nd console.log(..) statement does not coerce for printout

  Constants:
    - if value is not meant to change
    - declared at top of program, in one place
    - declare with capitals and _ between words
      Ex.
        var TAX_RATE=0.08;    //8% sales tax
        var amount = 99.99;
        amount=amount*2;
        amount=amount+(amount*TAX_RATE);
        console.log(amount);  // 215.9784
        console.log(amount.toFixed(2));   // "215.98"
       Where
        toFixed(..) = specify how many decimal places to round to
                      funtion to be accessed on 'number' values
        TAX_RATE = only constant by convention, nothing in program preventsvariable from being changed, but because in one place is easy to change for program should for ex tax increase, instead of searching out multiple instances throughout.

    ES6 includes new way to declare constants, using 'const' instead of 'var'
      Ex.
       const TAX_RATE=0.08;
       var amount=99.99;
    As useful as variables, but in addition prevents accidentally changing value somewhere else after initial setting.
      Ex. trying to assign different value to TAX_RATE after initial declaration would be rejected (failing with error in strict mode)

Blocks
  - Series of statements grouped together
  - Wrapped inside {..}
   Ex.
    var amount=99.99;
    // a general block
    {
      amount=amount*2;
      console.log(amount);    //199.98
    }
  - Typically attached to other control statement, ex 'if'
   Ex.
    var amount=99.99;
    //is amount big enough?
    if (amount>10) {     // <-- block attacked to 'if'
      amount=amount*2;
      console.log(amount);   // 199.98
    }
   Where
    {..} with its two statements (amount= and log)
    is attached to if(amount>10);
    thus statement only processed if conditional passes
  - block statement {..} does not need ; to conclude

Conditionals
  Decisions in your program
   Ex. If. = If this condition is true, do  following.
    var bank_balance=302.13;
    var amount=99.99;
    if (amount<bank_balance) {
        console.log("I want to buy this phone!");
    }
   Where
    (..) requires expression that can be either true or false. ie amount<bank_balance either is or isn't larger

  'Else' clause can be alternative if condition not true
   Ex.
    const ACCESSORY_PRICE=9.99;
    var bank_balance=302.13
    var amount=99.99;
    amount=amount*2;
    // can we afford the extra purchase?
    if (amount<bank_balance) {
        connsole.log("I'll take the accessory!");
        amount=amount+ACCESSORY_PRICE;
    }
    //otherwise
    else {
        console.log("No thanks.");
    }
   Where
    if amount<bank_balance is tue, "I'll take accessory!" will print and add 9.99 to amount variable.
    if false, else clause instructs to respond "No thanks" and amount remains unchanged.
  if statement expects boolean value, if given something that is not, will coerce

  JS defines list of values considered either "truthy" or "falsy"
    falsy: when coerced to boolean, become false. incl. 0 and ""
    truthy: if not falsy is automatically truthy.becomes true when coerced to boolean. incl 99.99 and "free"

  Other conditionals:
    - switch: shorthand for series of if..else statements
    Loops use conditional to determine if loop should continue or stop

Loops
  Job is to keep repeating set of actions as long as condition holds
  Includes test condition as well as block{..}
    Iteration = each time loop block executes
     Ex.
      while (numOfCustomers>0) {
          console.log("How may I help you?");
          //help the customer...
          numOfCustomers=numOfCustomers-1;
      }
      //versus:
      do {
          console.log("How may I help you?");
          //helt the customer...
          numOfCustomers=numOfCustomers=1;
      } while(numOfcustomers>0)
     Where
      Only difference is whether conditional is tested before or after first iteration. (while)/(do..while)
      In either case if conditional tests false next iteration will not run.
      If initial condition false, 'while' loop will never run but do..while loop will run just first time.

    Languages almost always count from 0 up, not 1. Replace value 0 with i when wanting to count numbers

    conditional tested on each iteration, as if there is implied 'if' statement in loop

    Break statement used to stop loop.
      Ex.
        var i=0;
        // a 'while true' loop will run forever, right?
        while (true) {
            //stop the loop?
            if ((i<=9) ===false) {
                break;
          }
          console.log(i);i=i+1;
        }
        // 0 1 2 3 4 5 6 7 8 9
       ^not practical approach

    while or do..while can accomplish task manually,
    'for' loop is made for this purpose
      Ex.
        for (var i=0; i<=9; i=i+1) {
            console.log(i);
        }
        // 0 1 2 3 4 5 6 7 8 9
       Where
        i<=9 true for 1st 10 iterations (i values 0 through 9)
        becomes false  once i=10
      for loop 3 clauses
        - initial clause (var i=0)
        - conditional test clause (i<=9)
        - update clause (i=i+1)
      Thus 'for' more compact & easier to understand & write
     Other specialized loop forms exist to iterate over specific values, ex. properties of object, but "loop until condition fails" holds for all loops regardless of form.

Functions
  Section of code that can be 'called' to be repeated. aka reusable piece
    Ex.
      fucntion printAmount() {
          console.log(amount.toFixed(2));
      }
      var amount=99.99;
      printAmount();   // "99.99"
      amount=amount*2;
      printAmount();   // "199.98"
    or
      function printAmount(amt) {
          console.log(amt.toFixed(2));
      }
      function formatAmount() {
          return "$"+amount.toFixed(2));
      }
      var amount=99.99;
      printAmount(amount*2);    //"199.98"
      amount=formatAmount();
      console.log(amount);      //"$99.99"
     Where
      function printAmount(..) takes parameter called 'amt'
      function formatAmount() returns value
        -can also be combined
    Parameter:
      of a function. ex. amt in printAmount(amt)

  Used for code that will be called multiple times
  or useful for organizing related bits of code in named locations, even if only called once.
    Ex.
      const TAX_RATE=0.08;
      function calculateFinalPurchaseAmount(amt) {
      //calculate the new amount with the tax
      amt=amt+(amt*TAX_RATE);
      return amt;
      }
      var amount=99.99;
      amount=calculatePurchaseAmount(amount);
      console.log(amount.toFixed(2));
     Where
      calculateFinalPurchaseAmount(..) only called once, but makes logic of final statement (amount=calculateFinal..) cleaner

Scope
  aka Lexical Scope
  - in JS all functions gets own scope
  - = Collection of variables + rules for how said variables accessed by name.
  - Only code inside function can access said function's 'scoped' variables
  - Variable name has to be unique within same scope, but same name can appear in different scopes
    Ex.
      function one() {
      //this 'a' only belongs to the 'one()' function
      var a=1;
      console.log(a);
      }
      function two() {
      //this 'a' only belongs to the 'two()' function
      var a=2;
      console.log(a);
      }
      one();    // 1
      two();    // 2
     Where
      Can't access a=1 in function two(); it's scope is only within {} thus its a=2 only

    - Scope can be nested in another scope
      where nested scope can access code inside either scope
      Ex.
        function outer() {
            var a=1;
            function inner() {
                var b=2;
                //we can access both 'a' and 'b' here
                console.log(a+b);  //3
        }
            inner();
            //we can only access 'a' here
            console.log(a);    //1
        }
        outer();
  - code in one scope can access variables in either scope outside of it
      Thus
        code inside inner() has access to both a and b
        code inside outer() only has access to a, not b because b variable only inside inner()
      Ex.
        const TAX_RATE=0.08;
        function calculateFinalPurchaseAmount(amt) {
        // calculate the new amoutn with the tax
        amt=amt+(amt*TAX_RATE);
        // return the new amount
        return amt;
        }
       Where
        TAX_RATE constant (var) is accesable from inside calculateFinalPurchaseAmount(..) funnction, even though unpassed

Review
  Operators: perform actions on values
  Values&types: to perform different kinds of actions
  Variables: store data (state) during execution.
  Conditionals: make decisions
  loops: repeat tasks
  functions: organize into logical and reusable chunks.

Code comments for writing more readable, understandable and useable code.

------------------------------------------------------------------------

# Chapter 2 - Into JS
 Overview of topics covered in rest of YDKJS books

# Values & Types

JS has typed values, not variables.

  Built-in types:
      - string   ---  a="Hello world";
      - number   ---  a=42;
      - boolean   ---  a=true;
      - null & undefined   ---  var a;
      - object   ---  a={b:"c"};
      - symbol   ---

  ```typeof``` operator can examine value and tell you which type it is.
  - answer always in 'string'
  - ``typeof a`` does not return type of a but rather type of variable
    held by a.
  - only values have types in JS, variables just container.
  - ``a=null;  typeof a; returns "object" --longstanding bug now commonly
    employed.
  - "Undefined" type reached in variety of ways, including undeclared
    variable, functions that return no value, or usage of ``void`` operator

Objects
 Refers to compound value where properties (named locations) can be set, each holding own values of any type.
  Ex.
    ```javascript
    var obj = {
      a: "hello world",
      b: 42,
      c: true
    };
    obj.a;  //"hello world"
    obj.b;  //42
    obj.c;  //true
    obj["a"]; //"hello world"
    obj["b"]; //42
    obj["c"]; //true
    ```
   Where
    obj
    +----++----++----++----++----++----+
    | a: "hello world"| b: 42 | c: true |
    +----++----++----++----++----++----+

  - Properties accessed by dot notation (obj.a) or bracket notation (obb["a"]).
  - Dot notation preferred for brevity and readability.

 [Bracket] notation:
  - Useful if property name contains special characters Ex.
      obj["hello world"] -- aka keys (properties accessed by bracket not).
  - requires either variable or string 'literal', wrapped in ".." or '..'
  - useful for accessing property/key but name is stored in another var
      Ex.
        ```javascript
        var obj = {
          a: "hello world",
          b: 42
        };
        var b = "a";
        obj[b];      //"hello world"
        obj["b"];   // 42
        ```
  Other value types:
    - array
    - functions
      ^ More correctly a sub-type of 'object' type.

  Array:
    'object' that holds values not in keys but numerically indexed positions
      Ex.
        ```javascript
        var arr = [
        "hello word",
        42,
        true
        ];
        arr[0];        // "hello world"
        arr[1];        // 42
        arr[2];        // true
        arr.length;    // "object"
        typeof arr;    // "object"
        ```
       Where
         arr
         +----++----++----++----++----++----+
         | 0: "hello world"| 1: 42 | 2: true |
         +----++----++----++----++----++----+
     - special objects, can also have properties, incl updated 'length'
      property.
    - Array can be used as normal object with own name properties,
    - or use `object` and give nomeric properties (0,1,) <- improper usage
    - best use: for numerically positioned values, vs `object` for named properties.

  Functions:
     ```javascript
     function foo() {
           return 42;
     }
     foo.bar = "hello world";

     typeof foo;    // "function"
     typeof foo();  // "number"
     typeof foo.bar; // "string"
     ```
    Where
     implies it can have properties, but typically will only use function obj properties in limited cases
